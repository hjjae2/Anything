### 인덱스(Index)

**테이블의 검색 성능(속도)를 향상시켜주기 위해 사용되는 기술(혹은 자료 구조)입니다.**

**데이터들을 정렬된 상태**로 관리하여, 검색 시 이점이 있습니다.

- **Order by 효율성** : 이미 정렬되어 있기에 인덱스에서 관리된 형태 그대로 가져올 수 있다.
- **Min, Max 효율성** : 첫 번째 값, 마지막 값을 가져와 사용할 수 있다.
- **Where 효율성** : 테이블의 데이터들은 내부적으로는 정렬되지 않은 상태로 저장되기 때문에 인덱스 없는 검색 시 Full-Scan이 필요하다. 인덱스 사용 시에는 정렬된 형태로 값을 저장하기 때문에 빠르게 데이터를 검색할 수 있다.

<br>

### 인덱스(Index) 자료구조

**해시 테이블**

- 해시테이블은 등호(=)연산에만 특화되어있다.
부등호 연산에는 적합하지 않다.

**RedBlack-Tree**

- 밸런스를 유지하는 트리이다.
- 하나의 노드에 하나의 값만을 갖는다. 이 특징은 DB 인덱스로써 적절하지 않다. (값을 탐색할 때, 하나의 노드에 배열의 형태로 여러 값이 있는 것과 노드 마다 주소를 찾아가야하는 차이이다.)

**배열**

- 배열로 관리한다면 탐색 시에는 이점이 있다.
- 값 추가, 수정, 삭제 등의 경우 배열의 순서를 다시 유지해주어야 하는 비용이 크다. (DB 인덱스 자료구조로 적절하지 않다.)

<br>

**B-Tree**

- 중간 노드를 포함한 모든 노드에서 Key, Data를 담을 수 있다.
- 2개보다 더 많은 자식 노드를 가질 수 있다.(Binary Tree 를 확장한 구조이다.) 하나의 노드에 N개의 자료를 가지고 있다면, `N차 B-Tree`라고 부른다.
- 트리의 균형을 맞춘다.
- 각 노드 = Disk Block 과 같다.

<br>

**B+Tree**
  
- 리프 노드에만 Key, Data를 담는다. 

- 리프노드끼리는 (양방향, Double)연결리스트로 연결되어 있다. (부등호 검색과 같은 것이나 순차적으로 순회할 필요가 있을 때 이점이 있을 것이다.)
- 중간 노드에는 Key 만을 갖는다. 따라서, 더 많은 값들을 수용할 수 있다. (= 더 적은 수의 노드를 사용한다 = 더 적은 용량을 차지한다 = B-Tree에 비해 상대적으로 더 적은 Disk Block을 읽어도 된다.)

<br><br>

### 참고

- [데이터베이스 인덱스는 왜 'B-Tree'를 선택하였는가](https://helloinyong.tistory.com/296)
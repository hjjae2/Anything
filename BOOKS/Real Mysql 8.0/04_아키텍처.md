**Mysql 서버 = Mysql 엔진 + Storage 엔진**

- Handler API(핸들러 API)를 구현하여, (추가적인) Storage 엔진을 개발/적용할 수 있다.

<br>

## 4.1 MySQL 엔진 아키텍처

> Mysql 서버는 다른 DBMS 에 비해 구조가 독특하다고 볼 수 있다.

아래와 같이 구조를 나눠볼 수 있다. <br>

|Mysql 엔진|Storage 엔진|
|-|-|
|- 커넥션 핸들러 <br>- SQL 파서 <br>- SQL 옵티마이저<br>- 캐시 & 버퍼<br>- ...|- InnoDB<br>- MyISAM<br>- ...|

```text
            커넥션 핸들러

SQL 파서 , SQL 옵티마이저 , 캐시 & 버퍼

    스토리지 엔진 (InnoDB, MyISAM, ...)

    DISK (Data File, Log File, ...)
```

> \* 단, 'Mysql 엔진' 이라는 용어는 공식적인 용어는 아닌 것 같기도하다. <br>
> \* 'Storage 엔진' 은 공식적인 용어인 것 같다. 

<br>

**Mysql 엔진**

DBMS 두뇌역할 (쿼리 분석, 최적화 등)

- group by, order by 등의 복잡한 처리는 Mysql 엔진(쿼리 실행기)에서 처리

> **\*'데이터 쓰기/읽기 작업'은 (반드시) '핸들러 API' 통해 스토리지 엔진에 작업 요청**

<br>

**스토리지 엔진**

실제로 디스크로부터 데이터를 읽어오는 역할

> **\* 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM), 버퍼 풀(InnoDB) 와 같은 기능을 내장**

<br><br>

**Mysql 스레딩 구조**

- 프로세스 기반 X
- 스레드 기반 O
  - 포그라운드 스레드
  - 백그라운드 스레드

> Mysql 커뮤니티 에디션 : 전통적인 Thread 모델 = Thread Pool 모델 사용 X <br>
> Mysql 엔터프라이즈 에디션 (혹은 Percona Mysql 서버) : Thread Pool 모델 사용 가능

**포그라운드 Thread**

- (Thread Pool을 사용하지 않았다는 가정하에) 최소 Mysql 서버에 접속된 클라이언트 수만큼 존재
- 각 클라이언트의 요청(쿼리) 처리
- 커넥션 종료 시 (해당 커넥션을 담당하던) Thread는 Thread Cache 되돌아가거나 혹은 소멸
- 데이터를 Buffer 혹은 Cache 로부터 가져온다.
  - Buffer 혹은 Cache에 없는 경우 디스크, 인덱스로부터 데이터 가져온다.
    - MyISAM : 포그라운드 Thread 가 처리
    - InnoDB : 백그라운드 Thread 에 위임

<br>

**백그라운드 Thread**

> MyISAM 의 경우 해당하지 않는다.

아래의 작업들이 백그라운드 Thread 처리

- Insert Buffer Merge(병합) 스레드
- Log 를 Disk 로 기록하는 스레드 (로그 스레드)
- InnoDB Buffer Pool 의 데이터를 disk 에 기록 (쓰기 스레드)
- 데이터를 버퍼(buffer)로 읽어오는 스레드
- Lock, DeadLock 모니터링 스레드

> 이 중 '로그 스레드', '쓰기 스레드' 가 가장 중요하다고 한다.

<br>

사용자의 요청을 처리하는 중 '데이터 쓰기 작업' 은 지연될 수 있다. <br>
- 대부분의 DBMS 에서는 쓰기 지연 기능(버퍼링)이 포함되어 있다. (대부분의 경우 응답이 더 빠르다.)
- MyISAM 의 경우 포그라운드 스레드(사용자 스레드)가 '쓰기 작업'까지 처리한다. (따라서, 쓰기 지연 기능 X, 바로바로 처리한다.)

사용자의 요청을 처리하는 중 '데이터 읽기 작업' 은 지연될 수 없다.

<br>

**메모리 할당 및 사용 구조**

> 각 운영체제의 메모리 할당 방식은 매우 복잡하다. <br>
> 요청된 메모리 공간을 100% 할당해줄 수도 있고, 요청된 공간을 예약만 해두고 실제 필요할 때마다 할당해주는 경우도 있다. <br>
> Mysql 서버가 실제로 사용하는 정확한 메모리의 양을 측정하는 것도 쉽지 않다고 한다.
> (따라서 단순하게 시스템 변수로 설정해둔만큼 메모리를 할당받는다고 생각해도 된다고 함)

Mysql 메모리 공간 = 글로벌 메모리 영역(Global Memory Area) + 로컬 메모리 영역(Local/Session Memory Area)

글로벌 메모리 영역 <br>
- 모든 쓰레드(클라이언트)가 공유 
  - 즉, 오직 하나의 메모리 공간만 할당
  - 단, (필요에 따라) 2개 이상의 메모리 공간을 할당 받을 수 있음
- 메모리 영역의 설정값에 따라 (최악의 경우) 서버가 죽을 수 있음
- Mysql 서버 시작 시 운영체제로부터 할당
  - InnoDB 버퍼 풀 / MyISAM 키 캐시
  - bin_log 버퍼
  - redo_log 버퍼
  - table cache
  - ...


<br>

로컬 메모리 영역<br>
- 클라이언트 접속(연결) 시 할당
  - 클라이언트 쓰레드가 쿼리를 처리하기 위해 사용하는 메모리 영역
  - (클라이언트 쓰레드 별로) 독립적인 영역
  - '클라이언트의 메모리 영역의 설정값'은 '글로벌 메모리 영역의 설정값'보다 비교적 덜 주의해서 설정해도 됨
- 각 쿼리의 용도별로 공간이 할당
  - 필요 시에만 공간이 할당되는 개념
  - 필요하지 않은 경우 공간이 할당되지 않을 수 있음
- 커넥션 후 계속 할당되어 있는 영역이 있음 (커넥션 버퍼, 결과 버퍼)
- 커넥션 후 쿼리 실행 순간에만 할당되고 곧바로 해제되는 영역이 있음 (조인 버퍼, 소트 버퍼)
- 조인 버퍼 (join buffer)
- 정렬 버퍼 (sort buffer)
- 리드 버퍼 (read buffer)
- 네트워크 버퍼 (network buffer)
- ...

<br>

**플러그인 모델**

Mysql 독특한 구조(기능) 중 대표적인 기능 : '플러그인 모델'

단순히 스토리지 엔진 뿐만 아니라, 다양한 기능을 플러그인 모델을 통해 지원한다.

플러그인의 종류
- 스토리지 엔진
  - ARCHIVE
  - BLACKHOLE
  - MyISAM
  - FEDERATED
  - InnoDB
  - MEMORY
  - CSV
  - PERFORMANCE_SCHEMA
  - ...
- 인증
- 파서 (전문 검색 파서 등)
- 커넥션 제어 
- ...

<br>

**컴포넌트**

Mysql 8.0 부터는 아래의 '플러그인 단점'을 보완하기 위해 '컴포넌트'로 대체/지원한다.

플러그인 단점 <br>
- Mysql 서버와 통신 OK, 플러그인끼리는 통신할 수 없음
- Mysql 서버의 변수, 함수를 직접 호출 (캠슐화 X)
- 상호 의존 관계 설정할 수 없음 => 초기화 어려움
  - (\* 누가 먼저 실행이 되어야 하는지 일일히 확인해줘야 하는 의미인 것 같다.)


<br>

**쿼리 실행 구조**

```text
SQL 요청 -> MySQL 엔진
           - 쿼리 파서
           - 전처리기
           - 옵티마이저 (쿼리 변환, 쿼리 최적화, 실행 계획 수립)
           - 쿼리 실행기  ->  스토리지 엔진
                            - InnoDB
                            - MyISAM
                            - ...
```

**쿼리 파서**

요청온 쿼리의 기본적인 문법을 확인한다.

1. 쿼리 문장을 토큰화
2. 트리 형태의 구조로 생성

**전처리기**

쿼리 파서에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인한다.

- 실제로 해당 테이블, 컬럼이 존재하는지?
- 접근 권한이 있는지?

<br>

**옵티마이저**

> \* DBMS 의 두뇌라고 한다. 아주 중요하다.

가장 저렴한 비용으로, 최적화된 쿼리로 실행할 수 있도록 한다.

<br>

**실행 엔진**

실행 엔진은 '핸들러 API'를 통해 (옵티마이저에 의해)최적화된 쿼리를 처리한다.

<br>

**쿼리 캐시**

Mysql 8.0 부터 해당 기능을 제거했다.

아래와 같은 이유이다.


- Key : SQL 쿼리
- Value : SQL 실행 결과 (Memory)

해당 쿼리에 연관된 테이블의 데이터가 변경되면, 관련된 캐시들은 모두 삭제해야 했다. <br>
\* (따라서) 오히려 성능(동시성) 저하, 버그가 많았다고 한다.

<br>

**스레드 풀**

> 'Percona Server (Thread Pool 플러그인)' 알아볼 것

Thread Pool 의 스레드 수를 무작정 많이 늘리는 것은 좋지 않다. <br>
- 스케줄링 대상 많아짐
- 불필요한 컨텍스트 스위칭 비용 커짐

<br>

**메타데이터(데이터 딕셔너리) 관리**

메타데이터(데이터 딕셔너리) : 테이블 구조 정보, 스토어드 프로그램 등의 정보

- Mysql 5.7 : File 관리
- Mysql 8.0 :
  - InnoDb : (InnoDB 스토리지 엔진의)DB,Table로 관리 (mysql db) (**트랜잭션 OK**)
  - 그 외 : File 관리

File 관리 시 문제점 : 중간에 오류 시 '일관성' 보장할 수 없다. (= DB가 깨졌다. 테이블이 깨졌다.)

> \* mysql DB 에 테이블 조회 시 실제로는 존재하되, 보이지 않음(select 불가) (사용자가 수정하지 못하게 하기 위함) <br>
> 대신 information_schema DB의 TABLES, COLUMNS 와 같은 view 를 통해 조회 가능



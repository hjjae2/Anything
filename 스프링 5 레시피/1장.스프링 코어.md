## 스프링 코어

아래 클래스는 스프링 IoC 컨테이너 (이하 IoC 컨테이너) 가 스캐닝한다.

자바 구성 클래스 (Java Configuration Class)

- `@Configuration`
- `@Bean`

자바 컴포넌트 클래스 (Java Component Class)

- `@Component`
- `@Controller`
- `@Service`
- `@Repository`

<br>

```
@Configuration
public class SequenceGeneratorConfiguration {

    @Bean
    public SequenceGenerator sequenceGenerator() {
        SequenceGenerator seqGen = new SequenceGenerator();

        ...

        return seqGen
    }
}
```

스프링은 @Configuration 의 클래스를 스캐닝하면, 그 안에서 (Bean 인스턴스를 생성해 반환하는) @Bean 자바 메소드를 찾는다.<br>
기본적으로 `Bean` 의 이름은 메소드 명을 따라간다. `Bean` 의 이름을 따로 명시하려면 `@Bean` 의 `name` 값을 설정한다.

<br><br>

### IoC 컨테이너

위의 Annotation(@Configuration, @Bean, @Component, ...) 를 스캐닝하기 위해선, 우선 Ioc 컨테이너를 인스턴스화 해야 한다.<br>
즉, IoC 컨테이너를 먼저 생성해야 한다.

스프링은 2 종류의 IoC 컨테이너(구현체, 인터페이스 등)를 제공한다.

1. **Bean Factory**
2. **Application Context**

(\* Application Context 는 빈 팩토리를 확장하기에, 되도록 Application Context 를 사용하는 것을 권장한다.)

**Application Context (인터페이스)의 구현체는 여러 개 있지만, 그 중 `AnnotationConfigApplicationContext` 를 권장한다.**

```
(IoC 인터페이스)                          (IoC 구현체)                              (자바 구성 클래스)
ApplicationContext context = new AnnotationConfigApplicationContext(SequenceGeneratorConfiguration.class);
```

<br><br>

### IoC 컨테이너에서 POJO 인스턴스(이하 빈) 가져오기

```
// context.getBean("빈 이름") 은 Object 형태를 return 한다.
SequenceGenerator generator = (SequenceGenerator) context.getBean("sequenceGenerator);

// context.getBean("빈 이름", "타입") 의 형태도 가능하다.
SequenceGenerator generator = context.getBean("sequenceGenerator, SequenceGenerator.class);
```

( \* Bean 이 한 개라면 빈 이름을 생략할 수 있다. )

<br><br>

### @Component 로 Bean 생성하기
```
public class Sequence {
    ...
}

public interface SequenceDao {
    ...
}

@Component("sequenceDao")   <-- @Component 사용, Bean ID 는 sequenceDao
public class SequenceDaoImpl implements SequenceDao {
    ...
}
```

`@Component` 에 이름을 설정하지 않으면 class 명의 camel-case 형태로 bean ID 가 설정된다.

`@Component` 는 Spring 이 스캐닝할 수 있도록 POJO 에 붙이는 범용 Annotation 이다.

Spring 에는 세 계층이 있다.

1. Persistence Layer
2. Service Layer
3. Persentation Layer

- `@Component`  : 범용 Annotation
- `@Repository` : Persistence(영속성) 계층을 위한 Annotation
- `@Service`    : Service(서비스) 계층을 위한 Annotation
- `@Controller` : Presentation(표현) 계층을 위한 Annotation

POJO 의 쓰임새(목적)이 명확하지 않을 땐 `@Component` 를 사용해도 된다. 그러나 되도록 (목적에 맞는) 구체적인 Annotation 을 사용하는 것을 권장한다.


<br><br>

### 컨테이너 스캐닝 시, 필터(필터링) 적용 (필터로 IoC 컨테이너 초기화)

( \* 스캐닝 하는 객체가 많아 질 때, 모든 패키지를 스캐닝하면 불필요하게 속도가 느려질 수 있다. )

Spring 이 지원하는 **필터 표현식** 은 4 종류이다.

1. annotation
2. assignable (assignable_type)
3. regex
4. aspectj

```
@ComponentScan(
    includeFilters = {
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.gg-pigs.*Dao", <-- 해당 패키지 내의 Dao 로 끝나는 클래스 스캐닝 (@Component 등의 Annotation 이 없어도 스캐닝 된다.)
                "com.gg-pigs.*Service"  <-- 해당 패키지 내의 Service 로 끝나는 클래스 스캐닝
            }
        )
    },
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            classes = {org.springframework.stereotype.Controller.class} <-- @Controller 클래스 제외
        )
    }
)
```

<br><br>

### POJO 의 의존성 해결

1. Setter 이용
2. `@Autowired` 이용 (+ `@Primary`, `@Qualifier`) <br>
   - `@Primary` : 타입이 같은 클래스(구현체)가 여럿일 때, 우선순위를 부여한다.
   - `@Qualifier`   : 타입이 같은 클래스(구현체)가 여럿일 때, 이름으로 무엇을 사용할지 결정할 수 있다.
3. `@Resource` 이용
4. `@Inject` 이용

```
// Setter 사용

@Configuratin
public class SequenceConfiguration {

    @Bean
    public DatePrefixGenerator datePrefixGenerator() {
        DatePrefixGenerator dpg = new DatePrefixGenerator();
        dpg.setPattern("yyyyMMdd");

        return dpg;
    }

    @Bean
    public SequenceGenerator sequenceGenerator() {
        SequenceGenrator sequence = new SequenceGenrator();
        ...
        sequence.setPrefixGenerator(datePrefixGenerator());  <-- 위의 datePrefixGenerator 메소드 (Bean 이름)

        return sequence;
    }
}
```

```
// Autowired 사용

@Service
public class SequenceService {

    @Autowired
    private SequenceDao sequenceDao;

    public void setSequenceDao(SequenceDao sequenceDao) {   <-- @Autowired 를 위해, 이 setter 가 필요한 것으로 알고 있음
        this.sequenceDao = sequenceDao;
    }

    ...
}
```

```
// Autowired 사용

@Service
public class SequenceService {

    @Autowired  <-- 위와 동일한 예제, Setter 메소드에 적용했을 경우이다.
    public void setSequenceDao(SequenceDao sequenceDao) {   <-- @Autowired 를 위해, 이 setter 가 필요한 것으로 알고 있음
        this.sequenceDao = sequenceDao;
    }

    ...
}

// 생성자의 경우에도 가능하다.
// Spring 4.3 이상의 버전부터는 생성자가 하나뿐인 클래스에서는 @Autowired 를 생략해도 된다. (기본으로 적용된다.)
```

```
// Resource 사용

public calss SequeceGenerator {
    
    @Resource
    private PrefixGenerator prefixGenerator;
}

```

```
// Inject 사용

public class SequenceGenerator {

    @Inject
    pirvate PrefixGenerator prefixGenerator;
}

```

<br><br>

### POJO Scope 지정

- `singleton` : IoC 컨테이너 당 Bean 인스턴스 1 개 생성
- `prototype` : 요청할 때마다 Bean 인스턴스 새롭게 생성
- `request` : HTTP 요청 당 1 개의 Bean 인스턴스 생성 (WebApplicationContext 만 해당)
- `session` : HTTP 세션 당 1 개의 Bean 인스턴스 생성 (WebApplicationContext 만 해당)
- `globalSession` : 전역 HTTP 세션 당 1개의 Bean 인스턴스 생성 (PortalApplicationContext 만 해당 (?))